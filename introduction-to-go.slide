Introduction to Go
Tokyo, Japan
11 Dec 2016

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* DRAFT PRESENTATION

THIS IS A DRAFT PRESENTATION.

* License and Materials

This presentation is licensed under the [[https://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike 4.0 International]] licence.

The materials for this presentation are available on GitHub:

.link https://github.com/davecheney/introduction-to-go

You are encouraged to remix, transform, or build upon the material, providing you give appropriate credit and distribute your contributions under the same license.

If you have suggestions or corrections to this presentation, please raise [[https://github.com/davecheney/introduction-to-go/isues][an issue on the GitHub project]].

* Agenda

This workshop is aimed at programmers with experience in another programming language and want to learn how to apply their skills to Go.

This workshop consists of five main sections:

- Basic Syntax
- Advanced Syntax
- Development environment and tooling
- The standard library
- Packages and applications

After each section we'll have time for questions.

As we work through the day there will be less of me talking, and more exercises to help you learn Go via doing.

* One more thing ...

This isn't a lecture, it's a conversation.

If you don't understand something, or think what you're hearing is incorrect, speak up.

* Introduction to Go

* Why a new language 

- motivation of go
 - when it started, 2007, released in 2009
 - why it started,

- opinionated
 - major opinions

* Safety

Typed, and type safe

        var i int = -1
        var u uint = 200

        i = u   // nope, incompatible types

Array accesses are bounds checked

        s := make([]string, 10)

        for i := 0; i <= 10; i++ {
                // oops
        }

* Safety (cont.)

No dangling pointers, return a stack value from a function with impunity.

- Compiler will move allocations to the heap if required.
- Escape analysis will move them back if not.

All memory is zeroed if not explicitly initialised

        var q int       // initialised to 0
        var f = 7       // initialised to 7, type defaults to int

No implicit conversions; booleans and integers are not aliases

        i := 2
        if i { ... }    // nope, no coercion to bool

* Good support for concurrency and communication

- Multicore is a reality.
- Multiprocessing is not a solution.
- Networking support baked into the standard library, integrated into the runtime.

* Garbage collected

Go is a garbage collected language.

- Eliminates the bookkeeping errors related to ownership of shared values.
- Eliminates an entire class of use after free and memory leak bugs.
- Enables simpler, cleaner, APIs.

The garbage collector handles heaps into the 100's of GB range, and is designed for extremely low "stop the world" pauses. In Go 1.7 these pauses are now less than 100 microseconds.

* Speed

Go is often noted for its fast compilation, but this is only one facet of the idea of Go being a _fast_ language to program in.

"False dichotomy of static languages being 'slow and painful' and dynamic languages being 'fast and fun'" -Rob Pike

"Clumsy type systems drive people to dynamically typed languages" -Robert Griesemer

Go is an attempt to demonstrate that a language can be both fast in terms of the programs it produces and fast (productive?) for the authors.

* Opinionated

Go is an opinionated language.

- Unused local variables are an error.
- Unused imports are also an error.
- The compiler does not issue warnings, only errors.
- A single way to format code as defined by `go`fmt`.

* Hello, http!

TODO: hello http example

- hello http
 - this has a lot going on, it shows directly, or indirectly almost all of the features of the language
 - compiled, concurrent, fast,
- but ...
 - this is my problem with the way that many languages are taught; they start with the big picture and immediately ask you, the student, to ignore, or take accept as true, many things which are not discussed until much later
 - this can be overwhelming, and I think there is a better way to introuduce Go.

* Basic Syntax

* Constants

A good place to start talking about Go are _Constants_.

Constants are values that do not change.

Here are some examples of constants:

 1
 "hello"
 false
 1.3

These are called _literal_constants_ because the value of evaluating each of these is the constant itself.

* Types of constants

There are six kinds of constants

- integer constants: `1`, `0`, `-6`, `9999999999999999999`, …
- floating point constants: `3.14`, `7.5e-2`, …
- complex number constants (rare): `1`-`0.707i`, …
- string constants: `"Hello,`東京"`, … 
- rune constants: `'a'`, `'す'`, `'シ'`, `'1'`, …
- boolean constants: `true`, `false`

* const

To make a constant, we declare one with the `const` keyword.

.play -edit src/const/const1/main.go /START OMIT/,/END OMIT/

Whenever you see a *Run* button on a slide, you can execute the code.

- Press the *Run* button now and see what happens. 
- Press the *Close* button to close the output window.

You can also edit the code right here in the slide.

- Edit the code to replace my name, with yours.
- All source code in Go is UTF-8, you can use Kanji.
- Press the *Run* button to see the results.
- If you make a mistake, just reload the page.

* Identifiers

This is a good time to talk about _identifiers_.

An identifier is a name your give to something in your code.

In Go an identifier is any word that starts with a _letter_.

.play -edit src/identifier/identifier1/main.go /START OMIT/,/END OMIT/

A letter is anything that Unicode defines to be a letter, this includes Kanji, Cyrilic, Aribic, etc.

- Identifiers are not restricted to ASCII, edit the slide and change `students` to `学生の` and press *Run*.
- If you make a mistake, just reload the page.

* Identifiers (cont.)

An identifier must start with a unicode letter, or the underscore character, `_`.

Numbers are not permitted at the start of an identifier, but can appear later in the identifier.

.play -edit src/identifier/identifier2/main.go /START OMIT/,/END OMIT/

Here are some examples of _invalid_ identifiers.

- Change the name of the identifier so that the program compiles.
- Press the *Run* button to see the results.
- If you make a mistake, just reload the page.

* Comments

Go supports two kinds of comments:

- Inline comments, which start with a double forward slash, `//`.
- Block comments, which start with a forward slash and a start, `/*`, and end with a start and forward slash, `*/`.

.play -edit src/comments/comments1/main.go /START OMIT/,/END OMIT/

Code that is commented out will not be compiled or run.

- Remove the comments in this program so it compiles.
- Press the *Run* button to see the results, it should compile and print `1`2`3`.
- If you make a mistake, just reload the page.

* Declarations

There are six kinds of _declarations_ in Go, we've seen one of them already.

They are:

- `const`: declares a new constant.
- `var`: declares a new variable.
- `type`: declares a new type.
- `func`: declares a new function, or method.
- `package`: declares the package this `.go` source file belongs to.
- `import`: declares that this package imports declaractions from another. 

We'll cover each of the remaining five declarations in this section.

* Variables

A variable holds a value that can be changed over time.

You _declare_ a new variable with the `var` declaration.

.play -edit src/variable/variable1/main.go /START OMIT/,/END OMIT/

Just like constants, variable _identifiers_ can be any any valid unicode word.

- Press the *Run* button to see the result.

_note_: The circumference is printed in scientific notication 😕, that's ok, we'll talk about how to fix it later when we talk about the `fmt` package.

* Unused variable declarations

Unused variables are often the source of bugs. If you declare a variable in the scope of your function but do not use it, the Go compiler will complain.

If the variable is unused, you should delete it, or assign it temporariliy to the magic variable called `_`.

.play -edit src/variable/variable2/main.go /START OMIT/,/END OMIT/

This program has four unused variables.

- Fix the program by uncommenting the two lines at the bottom.
- Delete, or comment out, the declaration of `自転車` as it is unused.
- Press the *Run* button to check that your program compiles.

* Statements

A statement in Go is a command to do something:

- _Declare_a_new_integer_variable_x_and_assign_it_the_value_10_.
- _While_x_less_than_20_perform_these_statements_.

There are several kinds of statements in Go, we've seen a few already.

The most common of _statements_ in Go are:

- Declarations: `const`pi`=`3.14159265359`, `type`Counter`int32`, …
- Assignments: `count`=`count`+`1`, …
- Increment/Decrement: `x++`, `y--`
- Conditionals: `if`…`{`…`}`else`{`…`}`, `switch`{`…`}`
- Loops: `for`…`{`…`}`
- Control flow: `break`, `fallthrough`, `continue`, `goto`, `return`.

* Assignment

It is common that you need to change the value stored in a variable, this is called _Assignment_.

.play -edit src/assignment/assignment1/main.go /START OMIT/,/END OMIT/

In this example, we declare

- Press *Run* to check that program prints, `1`, `2`, `4`.
- Update the program to declare a new variable, `z`, which has a value 2x larger than `y`.

* Assignment (cont.)

You can only assign a new value to _variables_.

.play -edit src/assignment/assignment2/main.go /START OMIT/,/END OMIT/

It is a syntax error to assign a new value to a constant.

- Press *Run* and see the program does not compile.
- Edit the sample code to change the declaration of `x` from a constant (`const`) to a variable (`var`).
- Press *Run* and check the program compiles and prints the correct answer, 2.

* Increment and decrement

Go supports a limited form of variable post-increment and post-deincrement, ie. `x++`, `x--`.

.play -edit src/increment/increment1/main.go /START OMIT/,/END OMIT/

- Press *Run* and see the program prints `2`,
- Edit the sample code to subtract `1` from `i` using the deincrement operator `i--`.
- Press *Run* and check the program compiles and prints the correct answer, 0.

* Increment and decrement (cont.)

`i++` and `i--` are _statements_, not an _expressions_, they do not produce a value.

.play -edit src/increment/increment2/main.go /START OMIT/,/END OMIT/

This program has a syntax error. 

- Edit the sample code to correct the error by moving the `i++` statement above the declaraction of `var`j`.
- Press *Run* and check the program compiles and prints the correct answer, 2, 2.

* Looping

Go has a single `for` loop construct that combines

- `while` _condition_ `{`…`}`
- `do`{`…`}`while` _condition_
- `do`{`…`}`until` _condition_

into one syntax.

- `for` _(init_statement)_; _condition_; _(post_statement)_ `{`…`}`

The parts of a `for` statement are:

- init statement: used to initalise the loop variable; `i`=`0`.
- condition: user to test if the loop is done; `i`<`10`, `true` means keep looping.
- post statement: user to increment the loop variable; `i++`, `i`=`i`-`1`.

* Looping (cont.) 

Let's practice using loops.

.play -edit src/loops/loops1/main.go /START OMIT/,/END OMIT/

This program counts from `1` to `10`, can you make it print only the _even_ numbers.

- Edit the program to make it print only the even numbers between `1` and `10`, inclusive.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

_note_: you do not need to put `(` braces around the `for` condition `)`.

* Looping (cont.) 

Let's practice counting down, this is where you would use a `while` loop in other languages.

.play -edit src/loops/loops2/main.go /START OMIT/,/END OMIT/

This program counts down from `10` to `1`, can you make it count from `7` to `3`.

- Edit the program to make it print only the numbers from `7` down to `3`.
- Press *Run* and check the program compiles and prints the correct answer, `7`, `6`, `5`, `4`, `3`.

_note_: this `for` loop only has a _condition_, there is no _init_statement_ or _post_statement_, so we can omit the semicolons, `;`.

* Conditional statements

Go has two conditional statements, `if` and `switch`.

- `if` is used to choose between two choices based on a _condition_.

- `switch` is used to choose between several choices:

* if

`if` is used when making a decision between two choices

 if v > 0 {
         println("v is greater than zero")
 } else {
         println("v is less than or equal to zero")
 }

In some cases the body of the `else` block may be omitted. This is very common when checking preconditions in a method of a function.

 if v == 0 {
         // nothing to do
         return
 }
 // handle v

* if (cont.)

Let's revisit our previous even numbers `for` loop example.

.play -edit src/conditionals/conditionals1/main.go /START OMIT/,/END OMIT/

This program counts from `1` to `10`, can you make it print only the _even_ numbers.

- Uncomment the `if`i%2`==`0`{` and `}` lines to make the program print only the even numbers between `1` and `10`.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

_note_: `%` is the _modulo_ operator in Go. All even numbers divide wholely by `2`, leaving `0` as their _modulo_ (or remainder).

* continue

Unlike languages like Java, `if` statements in Go are often used as _guard_clauses_.

We say that when everything is true the code reads from the top to the bottom of the page.

We can rewrite the previous program using a new statement, `continue`, which _skips_ the body of the loop.

.play -edit src/conditionals/conditionals2/main.go /START OMIT/,/END OMIT/

- Uncomment the `if`i%1`==`1`{`, `continue`, and `}` lines.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

* break

This program is an _infinite_loop_. There is no _condition_expression_ in the `for` loop.

We can use the `break` statement, which breaks out of the _current_ loop, to fix it.

.play -edit src/conditionals/conditionals3/main.go /START OMIT/,/END OMIT/

- Uncomment the `if`i`>`10`{`, `break`, and `}` lines.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

* Switch

* Type inference

In the examples so far we've avoided talking about types. This is because Go supports _type_inference_.

Type inference lets you omit the type of a variable during declaration.

For example:

 var i = 7

Go sees that `i` is being declared and initalised with the value `7`, which is an integer, so the compiler infers the type of `i` to be and `int`.

However if we did

 var s = "seven"

Go sees that `s` is being initalised with the _string_ `"seven"`, so the compiler infers the type of `s` to be a `string`.

* Explicit type declaration

Sometimes you will want to tell Go to use a specific type.

You do this when you declare a variable:

 var i int = 4
 var s string = "おはようございます"

Which tells the compiler that you are declaring `i` explicitly to be an `int` with the value `7`, and `s` to be a `string` with the value `"おはようございます"`

We'll talk about the kinds of types that Go supports on the next slide.

* Types

Go is a strongly typed language, like Java, C, C++, and Python. Go has nine kinds of types, they are:

- signed integers: `int8`, `int16`, `int32`, `int64`.
- unsigned integers: `uint8`, `uint6`, `uint32`, `uint64`.
- aliases: `byte` (`uint8`), `rune` (`int32`), `int` (`int32` or `int64`), `uint` (`uint32` or `uint64`).
- booleans: `bool`.
- strings: `string`.
- IEEE floating point: `float32`, `float64`.
- Complex types: `complex64`, `complex128`.
- Compound types: `array`, `slice`, `map`, `struct`.
- Pointer types: `*int`, `*bytes.Buffer`.

* Integer types

Integer types are the most common in Go.

Integer types come in two types; _signed_ and _unsigned_.

Integer types also come in several sizes, represented by the number of bits they represent; `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`.

Go has two integer types, `int` and `uint`, whose size depends on the platform you used to build your Go program.

* Integer types

Why does Go support so many kinds of integer types?

Different _sized_ integer types can accomodate different ranges of numbers.

.play -edit src/types/types1/main.go /START OMIT/,/END OMIT/

This program contains two type errors.

- Press *Run* to discover the two type errors.
- Fix the program by changing the declared types of `x` and `y`.
- Press *Run* and check the program compiles and prints the correct answer, `400`, `-7`

* Functions

Now it's time to talk about _functions_.

All Go you write is made up of functions, in fact, you've been writing functions all along.

.play -edit src/functions/functions1/main.go /START OMIT/,/END OMIT/

This is the same program as the previous example, showing the _function_declaration_, which was previously hidden.

- All Go programs start in a fuction called `main`, we call this the _main_function_.

* func

You can declare your own functions with the `func` declaration.

.play -edit src/functions/functions2/main.go /START OMIT/,/END OMIT/

This program declares two functions, `main` and `hello`.

- Uncomment the `println("こんにちは")` statement in `func`hello`.
- Press *Run* and check the program compiles and prints こんにちは three times.

_note_: `println` is a _built_in_ function provided by the Go compiler, you don't need to declare it.

* Function parameters

To make functions useful, you often need to pass _arguments_ to a function.

To pass an argument to a function, the type of the argument and the type of the function's formal parameter must be the same.

.play -edit src/functions/functions3/main.go /START OMIT/,/END OMIT/

In this program the type of the argument passed to `hello` does not match the type of the `name` parameter.

- Fix the declaration of `hello` so that the type of the parameter matches the type of the argument provided.
- Press *Run* and check the program compiles and prints こんにちは David

* Packages

Go code is arranged into packages.

Each source file in a Go program must begin with a `package` declaration, which declares.

A package is the unit in which software is shared and reused in Go.

We've been working in `package main`, which is the name of the package which contains the entry point to your program.

When your Go program

* main packages

This 

.play -edit src/packages/packages1/main.go

In this example the package name is wrong.

- Press *Run* and observe the compile error.
- Change the `package` declaration to make the program compile.
- Press *Run* to check that program prints its greeting.

* Import

- `import`: declares that this package imports declaractions from another. 

* Now you know the basics

Now you know the basics of Go.

You've learnt and experiemented with

- Constants, variables, and assignment.

* Advanced Syntax

* Advanced Syntax

In the previous section we executed code directly in this this deck.

In this section we'll use the Go Playground, a simple online code editor to perform our exercises.

The Go playground can format your code according to the canonical Go style.

TODO: talk about gofmt style.

Follow [[https://play.golang.org/p/0Hz57BQdTA][this link]] and press the *Format* button to see this in action.

* Literals

* Constant expressions

* Nil

`nil` is Go's version of `NULL`, `null`, `void`.

* Arrays

TODO: example, initalise array

* Slices

* Subslices


* Declaring your own types

* Zero value

In previous examples we've written code like this

 var counter = 1
 var name = "go"

Which both _declares_ and _initalises_ the variables `counter` and `name` respectively.

What happens if we have code like this

 var counter int
 var name string
 println(name, counter)

What will ths print?

* Zero value (cont.)

In Go, there is no unitialised memory. The Go runtime will always ensure that the memory allocated for every variable is initalised before use.

If we write something like 

 var counter int
 var name string

Then the memory assigned to the variables `counter` and `name` will be zeroed, as we have not provided an _initaliser_.

The value of `counter` will be zero, because that is the value of an `int` if we wrote `0` to its memory location.

The value of `name` will be `""` because that is the value of a string with zero length.

* Zero value (cont.)

Every type in Go has an associated _zero_value_. The value of that variable if we wrote zeros to its memory.

- The zero value for integer types: `int`, `int8`, `uint`, `uint64`, etc, is `0`.
- The zero value for floating point types: `float32`, `float64`, `complex128`, etc, is `0.0`.
- The zero value for arrays is the zero value for each element, ie. `[3]int` is `0`, `0`, `0`.
- The zero value for slices is `nil`.
- The zero valye for structs is the zero value for each field.

* Type conversions

Sometimes you have variables of different integer types, you can _convert_ from one type to another using a conversion _expression_.

The expression `T(v)` converts the value `v` to the type `T`.

.play -edit src/types/types1/main.go /START OMIT/,/END OMIT/

In this example the assignment of `y`=`x` fails because `x` and `y` are different integer types.

- Edit the code to _convert_ the type of `x` to `int` with `int(x)`.
- Press the *Run* button to see the results, it should compile and print `1`.

_note_: Other languages sometimes call this _casting_, we don't say this in Go because it is not the same.

* Type conversions (cont.)

SHOW WIDENING

* Type conversions (cont.)

SHOW NARROWING

* Type inference

* Short Declaration syntax

Maps
Structs
Scope
Constants

* Range

 code

You can use `range` over arrays, slices, maps, and channels.

* Multiple assignment

var x, y = 1, 2

* Multiple return values

* Variadic functions.

* Pointers

* Methods (must talk about types and packages first)

* Interfaces

* Empty Interface

* Development environment and tooling

* Development environment and tooling

This section focuses on the developer experience

- Installing Go.
- Setting up a `$GOPATH` workspace.
- Introduction to the `go` command.
- Writing unit tests with the go test command.

* Installing Go

The next NNN slides give examples of how to install Go on various systems.

The official installation documentation is here:

.link https://golang.org/doc/install

The current version of Go is 1.7.3.

Minor releases, 1.8, 1.9, etc, ship twice a year. 

Historically 2 or 3 bug fix releases occur during each six month period.

* Installing Go on OS X

Installing Go on OS X (also known as `darwin`) can be acomplished with

*Max OS Installer*

The Go project provides an `.pkg` installer, use:

.link https://storage.googleapis.com/golang/go1.7.3.darwin-amd64.pkg

_note_: Go 1.7.3 is the current releases as of this class.

*Homebrew*

If you use Homebrew to manage third party software on your Mac, use:

 brew install golang

* Installing Go on Windows

*MSI Installer*

The Go project provides a `.msi` installer for 32bit and 64bit Windows, use:

.link https://storage.googleapis.com/golang/go1.7.3.windows-amd64.msi Windows 64bit MSI installer
.link https://storage.googleapis.com/golang/go1.7.3.windows-386.msi Windows 32bit MSI installer

*.zip file*

The Go project provides a `.zip` file of the Go compiler and standard library, use:

.link https://storage.googleapis.com/golang/go1.7.3.windows-amd64.zip Windows 64bit zip file
.link https://storage.googleapis.com/golang/go1.7.3.windows-386.zip Windows 32bit zip file

Unzip the zip file and place it at `C:\Go`.

_note_: Go 1.7.3 is the current releases as of this class.

* Installing Go on Linux

Depending on your Linux distribution they may have an up to date version of Go, but this is rare.

The most reliable way to install the latest version of Go

_note_: Go 1.7.3 is the current releases as of this class.

* $GOPATH

TODO, explain `$GOPATH`.

* Go tool

Your Go installation comes with a tool we call the `go` tool, because that's its name.

The `go` tool can 

- compile your programs
- run your tests
- display documentation for a package
- fetch packages from the internet.

* go build

TODO: go build / go install

* go test

TODO: go test

* Writing tests

TODO: writing tests


* go doc

TODO: go doc / godoc 

Also, godoc.org

* Documenting packages with comments

Go code is traditionally documented with comments in the source code.

Show examples

* go get

TODO: go get

error handling

* The standard library

* The standard library

Go ships with a rich standard library of packages. This includes

- compression
- encoding and decoding of JSON and XML
- network handling
- HTTP client and server

This section will focus on the important packages from the standard library with exercises.

- katas
 - count the number of lines in a file (using bufio.Scanner)

* Packages and applications

* Packages and applications

- how to write a package
- how to layout a project
- package, project katas

TODO

* Conclusion

* Conclusion

Thank you very much for participating today, I hope that you enjoyed yourself and are encouraged to learn more about Go.


